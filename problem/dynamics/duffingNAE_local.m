% Local collocation for the duffing problem
% The states and costates are defined as follows
% x1 = X(1:N*M);
% x2 = X(N*M+1 : 2*N*M);
% L1 = X(2*N*M+1 : 3*N*M);
% L2 = reshape(L2,[N,M]);
% The residual vector is generated by including all the equations in each
% segment
function [R,J] = duffingNAE_local(x,BC,omega,beta,D,N,Neq,ns,M,J,J_local,Elb,Erb,SLb,SRb,R,LJ_local,BCtype)
%% State, Costates and BCs
x = reshape(x,[4*N,M]);
x1 = x(1:N,:);
x2 = x(N+1:2*N,:);
L1 = x(2*N+1:3*N,:);
L2 = x(3*N+1:4*N,:);

x10 = BC(1);
x20 = BC(2);
x1f = BC(3);
x2f = BC(4);


%% System of Equations
for k = 1 : M
    R(1:N,k)       = D(:,:,k)*x1(:,k) - x2(:,k);% Nx1 = NxN * Nx1 - Nx1;
    R(N+1:2*N,k)   = D(:,:,k)*x2(:,k) + omega^2*x1(:,k) + beta*x1(:,k).^3 + L2(:,k);
    R(2*N+1:3*N,k) = D(:,:,k)*L1(:,k) - L2(:,k).*(omega^2 + 3*beta*x1(:,k).^2);
    R(3*N+1:4*N,k) = D(:,:,k)*L2(:,k) + L1(:,k);    
    %Jacobian
    dR1dx1 = D(:,:,k);                          dR1dx2 = -eye(N);   dR1dL1 = zeros(N);  dR1dL2 = zeros(N);
    dR2dx1 = diag(omega^2+3*beta*x1(:,k).^2);   dR2dx2 = D(:,:,k);  dR2dL1 = zeros(N);  dR2dL2 = eye(N);
    dR3dx1 = diag(-6*beta*x1(:,k).*L2(:,k));    dR3dx2 = zeros(N);  dR3dL1 = D(:,:,k);  dR3dL2 = diag(-omega^2-3*beta*x1(:,k).^2);
    dR4dx1 = zeros(N);                          dR4dx2 = zeros(N);  dR4dL1 = eye(N);    dR4dL2 = D(:,:,k);
    % Jacobian boundary conditions
    if k == 1
        dR2dx1(1,:) = [1,zeros(1,N-1)]; dR2dx2(1,:) = zeros(1,N);       dR2dL1(1,:) = zeros(1,N); dR2dL2(1,:) = zeros(1,N);
        dR3dx1(1,:) = zeros(1,N);       dR3dx2(1,:) = [1,zeros(1,N-1)]; dR3dL1(1,:) = zeros(1,N); dR3dL2(1,:) = zeros(1,N);
%         dR1dx1(1,:) = [1,zeros(1,N-1)]; dR1dx2(1,:) = zeros(1,N);       dR1dL1(1,:) = zeros(1,N); dR1dL2(1,:) = zeros(1,N);
%         dR2dx1(1,:) = zeros(1,N);       dR2dx2(1,:) = [1,zeros(1,N-1)]; dR2dL1(1,:) = zeros(1,N); dR2dL2(1,:) = zeros(1,N);
    end
    if k == M
        dR2dx1(N,:) = [zeros(1,N-1),1]; dR2dx2(N,:) = zeros(1,N);       dR2dL1(N,:) = zeros(1,N); dR2dL2(N,:) = zeros(1,N);
        dR3dx1(N,:) = zeros(1,N);       dR3dx2(N,:) = [zeros(1,N-1),1]; dR3dL1(N,:) = zeros(1,N); dR3dL2(N,:) = zeros(1,N);
%         dR1dx1(N,:) = [zeros(1,N-1),1]; dR1dx2(N,:) = zeros(1,N);       dR1dL1(N,:) = zeros(1,N); dR1dL2(N,:) = zeros(1,N);
%         dR2dx1(N,:) = zeros(1,N);       dR2dx2(N,:) = [zeros(1,N-1),1]; dR2dL1(N,:) = zeros(1,N); dR2dL2(N,:) = zeros(1,N);
    end
    J_local(:,:,k) = [dR1dx1, dR1dx2, dR1dL1, dR1dL2; ...
                      dR2dx1, dR2dx2, dR2dL1, dR2dL2; ...
                      dR3dx1, dR3dx2, dR3dL1, dR3dL2;...
                      dR4dx1, dR4dx2, dR4dL1, dR4dL2];
    
    % Indices of states and segments
    Elb(k) = (k-1) * LJ_local+1;        %left boundary of each segment (Element left boundary)
    Erb(k) = Elb(k) + LJ_local- 1;      %right boundary of each segment
    for ii = 1 : Neq
        SLb(ii,:,k) = Elb(k)+ (ii-1)*N; %left boundary of each state ii for each element k (State left boundary)
        SRb(ii,:,k) = Elb(k) + ii*N-1;
        slb(ii) = (ii-1)*N+1;           %Left boundary of each state ii for the "local matrix"
        srb(ii) = ii*N;                 %Right boundary of each state ii for the "local matrix"
    end
    
    %Global Jacobian matrix
    J(Elb(k):Erb(k),Elb(k):Erb(k)) = J_local(:,:,k); %Global matrix
    
    %continuity conditions on the residual vector
    if k > 1 
        R(1,k)     = x1(1,k) - x1(end,k-1);
        R(N+1,k)   = x2(1,k) - x2(end,k-1);
        R(2*N+1,k) = L1(1,k) - L1(end,k-1);
        R(3*N+1,k) = L2(1,k) - L2(end,k-1);
    end
    % Continuity Conditions of the Jacobian Matrix
    if k > 1
        for ii = 1 : Neq
            J(SLb(ii,:,k):SLb(ii,:,k)+ns,:)                           = zeros(1+ns,length(J));
%             J(SLb(ii,:,k):SLb(ii,:,k)+ns,SLb(ii,:,k-1):SRb(ii,:,k-1)) =  J_local(srb(ii),slb(ii):srb(ii),k-1) ; %last value of 1st state in the local matrix placed in the first element of the global matrix
%             J(SLb(ii,:,k):SLb(ii,:,k)+ns,SLb(ii,:,k):SRb(ii,:,k))     = - J_local(slb(ii),slb(ii):srb(ii),k);     %first value of the 1st state in local matrix placed in the second element of the global matrix
            J(SLb(ii,:,k):SLb(ii,:,k)+ns,SLb(ii,:,k-1):SRb(ii,:,k-1)) = [zeros(1,N-1),-1];
            J(SLb(ii,:,k):SLb(ii,:,k)+ns,SLb(ii,:,k):SRb(ii,:,k)) = [1,zeros(1,N-1)];
        end
    end
end
%% Boundary conditions
switch BCtype
    case "fixed" %fixed final state
        
        R(N+1,1)   = x1(1,1) - x10;
        R(2*N+1,1) = x2(1,1) - x20;
        R(2*N,end)   = x1(end,end) - x1f;
        R(3*N,end)   = x2(end,end) - x2f;
%         R(1,1)   = x1(1,1) - x10;
%         R(N+1,1) = x2(1,1) - x20;
%         R(N,end)   = x1(end,end) - x1f;
%         R(2*N,end)   = x2(end,end) - x2f;
        
%         J(SLb(1,:,1),SLb(1,:,1):SRb(1,:,1)) = [1,zeros(1,N-1)];
%         J(SLb(2,:,1),SLb(2,:,1):SRb(2,:,1)) = [1,zeros(1,N-1)];
%         J(SRb(1,:,M),SLb(1,:,M):SRb(1,:,M)) = [zeros(1,N-1),1];
%         J(SRb(2,:,M),SLb(2,:,M):SRb(2,:,M)) = [zeros(1,N-1),1];
%         
% 
        


    case "free" %free final state
        s11 = 1;
        s22 = 1;
        R(1,1)   = x1(1,1) - x10;
        R(N+1,1) = x2(1,1) - x20;
        R(3*N,end) = L1(end,end) - s11*(x1(end,end)-x1f);
        R(4*N,end) = L2(end,end) - s22*(x2(end,end)-x2f);
end
%% Continuity conditions
% for kk = 2 : M
%     R(1,kk)     = x1(1,kk) - x1(end,kk-1);
%     R(N+1,kk)   = x2(1,kk) - x2(end,kk-1);
%     R(2*N+1,kk) = L1(1,kk) - L1(end,kk-1);
%     R(3*N+1,kk) = L2(1,kk) - L2(end,kk-1);
% end
%% Output Residual Vector
% Function output
 R = R(:);  %[all state segment1; all states segment2; ... ; all states last segment];





% if ip == 1
%     R = 1/2*(R'*R);
% end
%


% R(1:N) = D*x1 - x2;
% R(N+1:2*N) = D*x2 + omega^2*x1 + beta*x1.^3 + L2;
% R(2*N+1:3*N) = D*L1 - L2.*(omega^2 + 3*beta*x1.^2);
% R(3*N+1:4*N) = D*L2 + L1;
% % BCs
% R(1)   = x1(1) - x10;
% R(N+1) = x2(1) - x20;
% R(3*N)   = x1(end) - x1f;
% R(4*N)   = x2(end) - x2f;
% if ip == 1
%     R = 1/2*(R*R');
% end


